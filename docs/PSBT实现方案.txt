

入参：TxInputParams（确认后的），以及 Taproot 公钥（如前端拿到了）。
后端流程：

按输入类型填 PSBT 字段（关键）：
    P2PKH：Inputs[i].NonWitnessUtxo = 原交易（用 getrawtransaction 拿）；
    P2SH-P2WPKH：
        先从 地址识别为 P2SH；
        若前端给了 pubkey（OKX 可取），计算 keyhash = HASH160(pubkey)，构造 redeemScript = 0x0014<keyhash>，校验 HASH160(redeemScript) 是否等于地址中的脚本哈希；
        填：WitnessUtxo + RedeemScript；
    P2WPKH：填 WitnessUtxo；
    P2TR key-path：填 WitnessUtxo + 每个输入附公钥（OKX 要求；若前端给的是压缩公钥，转换为 x-only 存放到相应字段/自定义键，确保钱包可解析）；

    输出侧只对找零输出保持与输入同类型（无需额外元数据）；
    生成 OKX 用 psbtHex（注意：OKX 要十六进制，不是 base64）；
    返回：psbtHex、inputsIndexToSign（可选）和 summary。

PSBT 构建细节（V1 必做）
    统一使用 WitnessUtxo（Taproot/SegWit）；
    Legacy (P2PKH) 必须提供 NonWitnessUtxo（父交易原文），用 Core getrawtransaction 拿；
    P2SH-P2WPKH：自动生成并填 RedeemScript=0014<keyhash>（依赖获取到的 pubkey 做核验）；
    Taproot 输入：为每个输入附公钥（OKX 签名必要条件）；
    RBF：所有输入 nSequence < 0xfffffffe，建议统一用 0xfffffffd；
    LockTime：用“当前区块高度”；
    费率单位：内部 sat/vB，仅与 Core 交互时做单位换算（若用 feerate 参数）。
    说明：BIP32Derivation/路径等可选字段在“浏览器热钱包”场景通常不是硬性；Taproot 的“附公钥”是硬性。WSH/多签/tapscript 留待 Phase-2 做 descriptor 登记后一次性解决。

关键算法与校验
    选币：先尝试 BnB 精确匹配，失败再 knapsack；避免微找零；
    vsize 估算：
    P2PKH≈148 vB/输入，P2SH-P2WPKH≈91 vB，P2WPKH≈68 vB，P2TR≈57–65 vB/输入；输出 31–34 vB；固定头 ~10 vB；
    dust：输出 < dust 直接并费；
    P2SH 校验：HASH160(redeemScript) 必须等于地址中的脚本哈希，否则拒绝；
    网络参数：严格按 mainnet/signet 分流，地址前缀与脚本都校验。

最低落地检查清单
    Core 全节点 txindex=1；RPC 可用
    indexer ListUTXO(address) 正确
    MakePSBT() 覆盖四类输入（P2PKH / P2SH-P2WPKH / P2WPKH / P2TR）
    Taproot 输入附公钥 检查（缺则前端阻断）
    OKX：signPsbt(psbtHex) 流程打通（signet 先验）
    finalizepsbt → testmempoolaccept → sendrawtransaction 三连
    RBF 重签与 CPFP 提速接口留好
    监控：mempool 状态、失败原因、重试队列